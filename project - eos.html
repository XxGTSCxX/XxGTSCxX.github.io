<!doctype html>

<html>

<head>
	<meta charset="utf-8">

	<title>GTSC - Project: EOS</title>

	<link rel="icon" href="assets/logo.png">

	<!-- Required by Formatter ------------------------------------------------------------------------------>
	<link rel="stylesheet" type="text/css" href="styles/defaults.css">
	<link rel="stylesheet" type="text/css" href="styles/header.css"  >
	<link rel="stylesheet" type="text/css" href="styles/formats.css" >
	<link rel="stylesheet" type="text/css" href="styles/navbar.css"  >

	<script src="scripts/navbar.js"   ></script>
	<script src="scripts/formatter.js"></script>
	<!-- Required by Formatter End -------------------------------------------------------------------------->
</head>

<!-- Things are only displayed from here on out -->
<body>

	<!-------------------------------------------- Head of page --------------------------------------------->

	<header></header>

	<nav id="navbar" class="bar"></nav>

	<!------------------------------------------ Head of page End ------------------------------------------->

	<section style="padding-bottom: 100px;">
		<h2>EOS</h2>

		<hr>

		<div style="text-align: center;">
			<iframe width="100%" height="607.5" src="https://www.youtube.com/embed/wH1Y8KvImdE" frameborder="0"
				allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
				allowfullscreen></iframe>
			<subtitle style="font-size: 110%"><br>The game is still pending review and so its link will be updated
				accordingly once it's available.</subtitle>
		</div>

		<p>
			<b>EOS</b> is a 3rd year Digipen games project made with our team's custom 3D game engine named "DarkHorse".
			For this project, we used the C++ language and I spent the first semester as the producer before stepping
			down to fully focus on the technical aspects of the project due to our shortage on programmers. As a
			programmer, I mainly focused on the backend programming, such as:
		</p>

		<ul>
			<li><a href="#Property Reflection"  >Property Reflection  </a></li>
			<li><a href="#De/Serialiser"        >De/Serialiser        </a></li>
			<li><a href="#Configuration Manager">Configuration Manager</a></li>
			<li><a href="#3D Animations"        >3D Animations        </a></li>
			<li><a href="#Prefab System"        >Prefab System        </a></li>
		</ul>

		<p>
			This project was challenging in more ways than one and was a huge learning experience for the team as none
			of us were experienced on the needs for a game production pipeline and there were a lot of times where we
			made poor design decisions that lacked hindsight. For this write-up, I will be discussing about the mistakes
			I made in my choices and how I rectified or learned from them.
		</p>

		<p>
			We had a lot of issues as we were used to object-oriented programming and were trying to switch to
			data-oriented programming. Unfortunately, while the attempt was made, we were not successful at doing a full
			switch. This incomplete implementation actually caused caused us even more issues as we ended up with an
			engine that was trying to use conflicting ideologies.
		</p>

		<h3 id="Property Reflection">Property Reflection</h3>

		<p>
			For our property reflection, we utilised <a href="https://gitlab.com/LIONant/properties">LIONant's
				Properties project</a> to implement our reflection engine. It laid out majority of the ground work and I
			wrapped it in Reflection class such that it would be more readable in the C++ format that my fellow
			programmers were more familiar with.
		</p>

		<p>
			With the reflection system, my fellow programmers were able to use the macros to reflect their components and
			scripts. They are also able to find out the inheritance without the use of dynamic casts which can be very
			expensive.
		</p>

		<h4>Display VS Serialised Fields</h4>

		<p>
			Some of the tags that LIONant lets you add to the variabe you're reflecting include:
		</p>

		<ul>
			<li><code>property::flags::SHOW_READONLY</code></li>
			<li><code>property::flags::DONTSAVE     </code></li>
			<li><code>property::flags::DONTSHOW     </code></li>
			<li><code>property::flags::DISABLE      </code></li>
		</ul>

		<p>
			Unfortunately, in my naivety, I did not realise that the difference this provides is the ability for the editor
			and serialiser to identify if the field is meant to be displayed, and/or serialised when saving it to a file, or
			if fields are just to be displayed but not changed.
		</p>

		<p>
			This led to a lot of unnecessary complications with our component initialisation as my fellow programmers had
			the ability to reflect a variable via getter and setter functions. This meant that there was the potential of
			undefined behaviour as some functions might use uninitialised variables. While we could have just removed the
			ability for the programmer to do this, it introduced optimisation issues where additional variables might need
			to be used instead - causing the components to be unnecessarily fattened, or the inability to track if a variable
			is dirty or not.
		</p>

		<p>
			Honestly, I don't think this was an issue that got resolved properly. While we had added an initialisation
			phase to components so that the behaviour of the variables that affected one another could be dealt with there,
			it did not change the fact that reflect getters and setters could not use other variables or components to
			initialise itself. I was just lucky enough that nobody else had reflected getter and setter functions that used
			variables outside of the variable it was initialising so it wasn't as problematic as it could have been.
		</p>

		<h4 id="Reflecting Handles">Reflecting Handles</h4>

		<p>
			The purpose of handles are serialisable references to objects.
			(<a href="http://gamesfromwithin.com/managing-data-relationships">here</a>'s an article discussing its use and why
			we should use them). We use them to reference components, entities and resources. To serialise these objects without
			causing circular dependencies, we created handle bases which we reflect and have the actual handles inherit from
			them for the engine to know what types of object they reference to.
		</p>

		<p>
			Here's a rough example of the interface and implementation (NOTE: It's not the exact implementation we went with):
		</p>

<pre><code>
struct HandleBase
{
    constexpr HandleBase(UID const& uid = nulluid, Type::ID const& type_id = Type::INVALID_ID) noexcept
    : m_id{ uid }, m_type{ type_id }
    {}

    /* m_type is only available via a getter to maintain type safety */
    constexpr Type::ID GetType() const noexcept
    {
        return m_type;
    }

    UID m_id = nulluid;

protected:

    Type::ID m_type = Type::INVALID_ID;
};
</code></pre>

<pre><code>
template &lttypename object_t&gt
struct Handle : public HandleBase
{
    constexpr Handle(UID const& uid = nulluid) noexcept
    : HandleBase{ uid, Type::GetID&ltobject_t&gt() }
    {}

    object_t* operator->() const noexcept
    {
        return HandleManager::Get().GetObject&ltobject_t&gt(m_id);
    }

    object_t& operator*() const
    {
        return *operator->();
    }

    /* More stuff for safe casting and comparison operation (can be outside of class too) */
};
</code></pre>

		<p>
			<code>m_type</code> does not need to be serialised as the object itself would always know what is its own type.
			It's there for the engine/editor to know what's the type of the
			handle without using dynamic cast. How this is accomplished is via the <code>Type</code> class as they could do:
		</p>

<pre><code>
if (handle_obj.m_type == Type::GetID&lttype_t&gt())
{
    Handle&lttype_t&gt casted_handle = static_cast&ltHandle&lttype_t&gt&gt(handle_obj);
    /* Do your thing here */
}
</code></pre>

		<p>
			However, early on, I did not understand this, and we tried our best to brute force our way to reflect components and
			entity handles. This caused us to be unable to reflect entities and components using the reflection engine as it
			caused a circular dependency. Which in turn caused us to manually define how to reflect our scenes.
		</p>

		<p>
			By the time I had realised the way handles should have been reflected, we were only able to salvage the resource
			handles as things were too inter-mingled on the entity and component handle side. It would have taken me a while to
			implement the refactor (with legacy loading support) and it was unfortunately time that I could not afford. Of
			course, this causes a lot of problems down the road which I will discuss in my Prefabs and De/serialiser sections.
		</p>

		<h4>Reflecting Enums</h4>

		<p>
			The reflection of enums was something that I implemented much later down the road, but at this point, I had a better
			understanding on how we should utilise base classes and how reflection should work so it was easier to implement. The
			things that were implemented:
		</p>

		<ul>
			<li><code>EnumBase                        </code></li>
			<li><code>ReflectedEnumDetails&lttype_t&gt</code></li>
			<li><code>EnumDetails                     </code></li>
		</ul>

		<p>
			As mentioned in the <a href="#Reflecting Handles">Reflecting Handles</a> section, when attempting to reflect a
			templated class, it is best to create a base class that the template inherits from and reflect the base class instead.
			This base class is the <code>EnumBase</code>. However, as inheritance is not possible for enums, this enum base acts
			like more of a proxy.
		</p>

		<p>
			As the enum is also meant to be displayed and serialised as its string counter part, we also needed a means for the
			users to convert back and forth between its name and its value. This is where the
			<code>ReflectedEnumDetails&lttype_t&gt</code> comes in. It is used to store the map of enum names to their values.
		</p>

		<p>
			However, <code>ReflectedEnumDetails&lttype_t&gt</code> is a templated class, and if the users already knew which enum
			type they were dealing with, they would use the type directly. What we created the
			<code>ReflectedEnumDetails&lttype_t&gt</code> for is to enable the <code>EnumBase</code>, who would not know the C++ type
			of the enum to do a type cast (unless you manually handle each case to do a cast - but the whole point is to automate
			this, am I right?), to be able to access their respective maps of values without doing an actual type cast.
		</p>

		<p>
			This is where <code>EnumDetails</code> come in. This is the non-templated version of
			<code>ReflectedEnumDetails&lttype_t&gt</code> that stores the function pointers to the functions used to convert the
			strings to the values and vice versa. This object is created and stored into the Reflection system upon application
			instantiation via our <code>DH_REFLECT_ENUM</code> macro which anyone can use to get their information from.
		</p>

		<h3 id="De/Serialiser">De/Serialiser</h3>

		<p>
			One of the things that took me a really long time to understand was the "automation" of the serialiser and
			deserialiser should have used. Originally, I was under the impression that the Serialiser and Deserialiser
			should specify how each object should be de/serialised. This mistake however, led to a lot of circular
			dependencies in
		</p>

		<h3 id="Configuration Manager">Configuration Manager</h3>

		<p>
			The configuration manager acted as the manager for all "settings" files. I have come to regret the design
			decision that I went with since it was not the most refined and was born out of my ignorance to what the
			reflection system could have (should have) accomplished.
		</p>

		<p>
			The design for the configuration manager was something that we thought could go two ways:
		</p>

		<ol>
			<li>
				Type free version that uses a <code>std::variant</code> to serialise and deserialise the supported
				types so that the de/serialisation would be consistent across all config types.
			</li>
			<li>
				Inheritance version, where all configs inherit from a base config class and have a virtual
				function that can be used to serialise and deserialise itself.
			</li>
		</ol>

		<p>
			The first option gave a clean means to serialisation and deserialisation as any other user could create a
			config without worrying about how they should de/serialise them. The second provided type safety, ensuring
			the users that the data they required would exist.
		</p>

		<p>
			Naturally, properly utilising the reflection system would have given us the best of both worlds as it
			would have guarenteed both, however, since this was made before I properly understood and designed the
			reflection system, I opted to go with first option.
		</p>

		<p>
			This choice created an inconvenience, as the users will then have to manually initialise their type safe
			classes with syntax such as:
		</p>

		<code>ConfigManager::Get().GetConfig("config_name").GetField&lttype_t&gt("field_name");</code>

		<p>
			And to be safe, they would have to add many checks, such as:
		</p>

<pre class="p"><code>
if (ConfigManager::Get().HasConfig("config_name"))
{
    auto&& config = ConfigManager::Get().GetConfig("config_name");
    if (config.HasField&lttype_t&gt("field_name"))
    {
        auto&& config.GetField&lttype_t&gt("field_name");
    }
}
</code></pre>

		<p>
			And a simple spelling mistake meant that they would not be able to detect the issue as easily as a compile
			error would catch it (and we all know how painful it is to have to sit through a long compile time before
			realising that there was something wrong with the code when we run it).
		</p>

		<h3 id="3D Animations">3D Animations</h3>

		<p>
			There are three parts to this task and it was one of the tasks that caused me the most infuriating griefs
			from this project. For context, I had no experience with 3D modeling or rigging and so a lot of the
			concepts flew over my head and I constantly misunderstood stuff, causing me to take a while to understand.
		</p>

		<h4>Asset Compiler</h4>

		<p>
			The first part was to have a way for us to load the resources that the artists have made. However, instead
			of personally accounting and creating multiple format loaders for each file format (not to mention how
			buggy it would be since others would know better than we do), we needed an easier, more reliable way to
			process each asset type.
		</p>

		<p>
			This is where the asset compiler came in. We made use of the library
			<a href="https://github.com/assimp/assimp">Assimp</a> to do most of the heavy lifting. It was the hub for
			the different asset types to be converted into a single assimp object which we can then use to convert into
			our own singular file format.
		</p>

		<p>
			This was difficult as we needed to properly understand how the nodes in Assimp worked. At times it was
			difficult as some of the terminology overlapped with some of the commonly used 3D modeling tools such
			as Maya. There was also an added complexity to the graphs that Assimp would build as they do not just
			handle models, but the whole scene as well. This meant that there were more information to sift through
			than just a skinned mesh and its animation. It included lights, entity paths, etc. and we needed a way
			to check if a node was truly a bone, or if it was even part of a relevant animation (multiple animations
			could exist in one scene) which is near impossible from <i>just</i> the data that Assimp provides.
		</p>

		<p>
			This forced us to impose rules on the artists when they made their models to ensure that the compiler would
			be able to identify the relevant informations from the files and build the animations proper. However, once
			that was done, it made things a lot easier for us to move forward with.
		</p>

		<h4>Bone Animation</h4>

		<p>
			This was by far one of the most difficult part of the project that I had to deal with since it involved the
			very thing I was bad at - math. It took me two weeks to implement the Bone Animations and Skinned Mesh
			Renderer because of how long it took for me to understand the hierarchy of bones and nodes, the concept of
			pre and post transformations.
		</p>

		<h4>Skinned Mesh Renderer</h4>

		<p>
		</p>

		<h3 id="Prefab System">Prefab System</h3>

		<p>
			
		</p>
	</section>

	<!------------------------------------------- Footer of page -------------------------------------------->

	<footer></footer>

	<!----------------------------------------- Footer of page End ------------------------------------------>

	<script>
		window.onload   = function() { LoadFormat("project", "eos") };
		window.onscroll = function() { StickyNavbarOnScroll()       };
		LoadFormat("project", "eos");
	</script>

</body>

</html>