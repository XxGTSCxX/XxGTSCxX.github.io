<!doctype html>

<html>

<head>
	<meta charset="utf-8">

	<title>GTSC - Project: EOS</title>

	<link rel="icon" href="assets/logo.png">

	<link rel="stylesheet" type="text/css" href="styles/defaults.css">
	<link rel="stylesheet" type="text/css" href="styles/header.css"  >
	<link rel="stylesheet" type="text/css" href="styles/formats.css" >
	<link rel="stylesheet" type="text/css" href="styles/navbar.css"  >

	<script src="scripts/navbar.js"></script>
</head>

<!-- Things are only displayed from here on out -->
<body>

	<!-------------------------------------------- Head of page --------------------------------------------->

	<header>
		<img class="icon" style="margin-top: 25px;" src="assets/logo.png" alt="2019 Icon">

		<h1 style="margin-bottom: 0; margin-top: 0">GABRIELLE TAN SUAN CHOO</h1>

		<div class="row" style="margin-top: 0; min-width: 400px; overflow: hidden">
			<p class="column" style="text-align: right;  width: 48%; margin-top: 0">TECHNICAL UI DESIGNER</p>
			<p class="column" style="text-align: center; width: 4% ; margin-top: 0">❖                   </p>
			<p class="column" style="text-align: left;   width: 48%; margin-top: 0">TOOLS PROGRAMMER     </p>
		</div>
	</header>

	<nav id="navbar" class="bar">
		<a class="tab" href="index.html">HOME</a>
		<div class="droplist">
			<a class="tab target active" href="projects.html">PROJECTS</a>
			<div class="droplist-content">
				<a class="item" href="https://github.com/XxGTSCxX/Chilldew">Chilldew  </a>
				<a class="item" href="project - eos.html"                  ><b>EOS</b></a>
				<a class="item" href="project - dynamo.html"               >Dynamo    </a>
			</div>
		</div>
		<a class="tab" href="resume.html">RESUME</a>
	</nav>

	<!------------------------------------------ Head of page End ------------------------------------------->

	<section style="padding-bottom: 100px;">
		<h2>EOS</h2>

		<hr>

		<div style="text-align: center;">
			<iframe width="100%" height="607.5" src="https://www.youtube.com/embed/wH1Y8KvImdE" frameborder="0"
				allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
				allowfullscreen></iframe>
			<subtitle style="font-size: 110%"><br>The game is still pending review and so its link will be updated
				accordingly once it's available.</subtitle>
		</div>

		<p>
			<b>EOS</b> is a 3rd year Digipen games project made with our team's custom 3D game engine named "DarkHorse".
			For this project, we used the C++ language and I spent the first semester as the Producer before stepping
			down to fully focus on the technical aspects of the project due to our shortage on programmers. As a
			programmer, I mainly focused on the backend programming, such as:
		</p>

		<ul>
			<li><a href="#Property Reflection"  >Property Reflection  </a></li>
			<li><a href="#De/Serialiser"        >De/Serialiser        </a></li>
			<li><a href="#Configuration Manager">Configuration Manager</a></li>
			<li><a href="#3D Animations"        >3D Animations        </a></li>
			<li><a href="#Prefab System"        >Prefab System        </a></li>
		</ul>

		<p>
			This project was challenging in more ways than one and was a huge learning experience. For the most part
			there were a lot of misunderstandings on what I could do or what is needed by my fellow programmers. I will
			be discussing what I had implemented versus what I learnt from it and believe how I should have implemented
			things instead.
		</p>

		<h3 id="Property Reflection">Property Reflection</h3>

		<p>
			For our property reflection, we utilised <a href="https://gitlab.com/LIONant/properties">Lionant's
				Properties project</a> to implement our reflection engine. It laid out majority of the ground work and I
			wrapped it in Reflection class such that it would readable C++ format for my fellow programmers to use. What
			I
		</p>

		<h3 id="De/Serialiser">De/Serialiser</h3>

		<p>
			One of the things that took me a really long time to understand was the "automation" of the serialiser and
			deserialiser should have used. Originally, I was under the impression that the Serialiser and Deserialiser
			should specify how each object should be de/serialised. This mistake however, led to a lot of circular
			dependencies in
		</p>

		<h3 id="Configuration Manager">Configuration Manager</h3>

		<p>
			The configuration manager acted as the manager for all "settings" files. I have come to regret the design
			decision that I went with since it was not the most refined and was born out of my ignorance to what the
			reflection system could have (should have) accomplished.
		</p>

		<p>
			The design for the configuration manager was something that we thought could go two ways:
		</p>

		<ol>
			<li>
				Type free version that uses a <code>std::variant</code> to serialise and deserialise the supported
				types so that the de/serialisation would be consistent across all config types.
			</li>
			<li>
				Inheritance version, where all configs inherit from a base config class and have a virtual
				function that can be used to serialise and deserialise itself.
			</li>
		</ol>

		<p>
			The first option gave a clean means to serialisation and deserialisation as any other user could create a
			config without worrying about how they should de/serialise them. The second provided type safety, ensuring
			the users that the data they required would exist.
		</p>

		<p>
			Naturally, properly utilising the reflection system would have given us the best of both worlds as it
			would have guarenteed both, however, since this was made before I properly understood and designed the
			reflection system, I opted to go with first option.
		</p>

		<p>
			This choice created an inconvenience, as the users will then have to manually initialise their type safe
			classes with syntax such as:
		</p>

		<code>ConfigManager::Get().GetConfig("config_name").GetField&lttype_t&gt("field_name");</code>

		<p>
			And to be safe, they would have to add many checks, such as:
		</p>

<pre class="p"><code>
if (ConfigManager::Get().HasConfig("config_name"))
{
    auto&& config = ConfigManager::Get().GetConfig("config_name");
    if (config.HasField&lttype_t&gt("field_name"))
    {
        auto&& config.GetField&lttype_t&gt("field_name");
    }
}
</code></pre>

		<p>
			And a simple spelling mistake meant that they would not be able to detect the issue as easily as a compile
			error would catch it (and we all know how painful it is to have to sit through a long compile time before
			realising that there was something wrong with the code when we run it).
		</p>

		<h3 id="3D Animations">3D Animations</h3>

		<p>
			There are three parts to this task and it was one of the tasks that caused me the most infuriating griefs
			from this project. For context, I had no experience with 3D modeling or rigging and so a lot of the
			concepts flew over my head and I constantly misunderstood stuff, causing me to take a while to understand.
		</p>

		<h4>Asset Compiler</h4>

		<p>
			The first part was to have a way for us to load the resources that the artists have made. However, instead
			of personally accounting and creating multiple format loaders for each file format (not to mention how
			buggy it would be since others would know better than we do), we needed an easier, more reliable way to
			process each asset type.
		</p>

		<p>
			This is where the asset compiler came in. We made use of the library
			<a href="https://github.com/assimp/assimp">Assimp</a> to do most of the heavy lifting. It was the hub for
			the different asset types to be converted into a single assimp object which we can then use to convert into
			our own singular file format.
		</p>

		<p>
			This was difficult as we needed to properly understand how the nodes in Assimp worked. At times it was
			difficult as some of the terminology overlapped with some of the commonly used 3D modeling tools such
			as Maya. There was also an added complexity to the graphs that Assimp would build as they do not just
			handle models, but the whole scene as well. This meant that there were more information to sift through
			than just a skinned mesh and its animation. It included lights, entity paths, etc. and we needed a way
			to check if a node was truly a bone, or if it was even part of a relevant animation (multiple animations
			could exist in one scene) which is near impossible from <i>just</i> the data that Assimp provides.
		</p>

		<p>
			This forced us to impose rules on the artists when they made their models to ensure that the compiler would
			be able to identify the relevant informations from the files and build the animations proper. However, once
			that was done, it made things a lot easier for us to move forward with.
		</p>

		<h4>Bone Animation</h4>

		<p>
			This was by far one of the most difficult part of the project that I had to deal with since it involved the
			very thing I was bad at - math. It took me two weeks to implement the Bone Animations and Skinned Mesh
			Renderer because of how long it took for me to understand the hierarchy of bones and nodes, the concept of
			pre and post transformations.
		</p>

		<h4>Skinned Mesh Renderer</h4>

		<p>
		</p>

		<h3 id="Prefab System">Prefab System</h3>

		<p>
			
		</p>
	</section>

	<!------------------------------------------- Footer of page -------------------------------------------->

	<footer>
		<b>Email:</b> g.tan@digipen.edu ❖ <b>GitHub:</b>
		<a href="https://github.com/XxGTSCxX">XxGTSCxX</a> ❖ <b>LinkedIn:</b>
		<a href="https://www.linkedin.com/in/gabrielle-tan-suan-choo/">gabrielle-tan-suan-choo</a>
	</footer>

	<!----------------------------------------- Footer of page End ------------------------------------------>

	<script>
		window.onscroll = function() { StickyNavbarOnScroll() };
	</script>

</body>

</html>