<!doctype html>

<html>

<head>
	<meta charset="utf-8">

	<title>GTSC - Project: EOS</title>

	<link rel="icon" href="assets/logo.png">

	<!-- Required by Formatter ------------------------------------------------------------------------------>
	<link rel="stylesheet" type="text/css" href="styles/defaults.css">
	<link rel="stylesheet" type="text/css" href="styles/header.css"  >
	<link rel="stylesheet" type="text/css" href="styles/formats.css" >
	<link rel="stylesheet" type="text/css" href="styles/navbar.css"  >

	<script src="scripts/navbar.js"   ></script>
	<script src="scripts/formatter.js"></script>
	<!-- Required by Formatter End -------------------------------------------------------------------------->
</head>

<!-- Things are only displayed from here on out -->
<body>

	<!-------------------------------------------- Head of page --------------------------------------------->

	<header></header>

	<nav id="navbar" class="bar"></nav>

	<!------------------------------------------ Head of page End ------------------------------------------->

	<section style="padding-bottom: 100px;">
		<h2>EOS</h2>

		<hr>

		<div style="text-align: center;">
			<iframe width="100%" height="607.5" src="https://www.youtube.com/embed/wH1Y8KvImdE" frameborder="0"
				allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
				allowfullscreen></iframe>
			<subtitle style="font-size: 110%"><br>The game is still pending review and so its link will be updated
				accordingly once it's available.</subtitle>
		</div>

		<p>
			<b>EOS</b> is a 3rd year Digipen games project made with our team's custom 3D game engine named "DarkHorse".
			For this project, we used the C++ language and I spent the first semester as the producer before stepping
			down to fully focus on the technical aspects of the project due to our shortage on programmers. As a
			programmer, I mainly focused on the backend programming, such as:
		</p>

		<ul>
			<li><a href="#Property Reflection"  >Property Reflection  </a></li>
			<li><a href="#De/Serialiser"        >De/Serialiser        </a></li>
			<li><a href="#Configuration Manager">Configuration Manager</a></li>
			<li><a href="#3D Animations"        >3D Animations        </a></li>
			<li><a href="#Prefab System"        >Prefab System        </a></li>
		</ul>

		<p>
			This project was challenging in more ways than one and was a huge learning experience for the team as none
			of us were experienced on the needs for a game production pipeline and there were a lot of times where we
			made poor design decisions that lacked hindsight. For this write-up, I will be discussing about the mistakes
			I made in my choices and how I rectified or learned from them.
		</p>

		<p>
			We had a lot of issues as we were used to object-oriented programming and were trying to switch to
			data-oriented programming. This led to a steep learning curve that a lot of misconceptions and 
		</p>

		<h3 id="Property Reflection">Property Reflection</h3>

		<p>
			Dealing with reflection helped me appreciate the benefits that data-oriented programming brings to the table.
			Unfortunately, while an attempt to switch to a data-oriented method was made, we were not successful at doing
			a full switch. That actually caused us even more issues as we ended up with an engine that was trying to use
			conflicting ideologies.
		</p>

		<p>
			For our property reflection, we utilised <a href="https://gitlab.com/LIONant/properties">LIONant's
				Properties project</a> to implement our reflection engine. It laid out majority of the ground work and I
			wrapped it in Reflection class such that it would be more readable in the C++ format that my fellow
			programmers were more familiar with.
		</p>

		<p>
			With the reflection system, my fellow programmers were able to use the macros to reflect their components and
			scripts. They are also able to find out the inheritance without the use of dynamic casts which can be very
			expensive.
		</p>

		<h4>Display VS Serialised Fields</h4>

		<p>
			Some of the tags that LIONant lets you add to the variabe you're reflecting include:
		</p>

		<ul>
			<li><code>property::flags::SHOW_READONLY</code></li>
			<li><code>property::flags::DONTSAVE     </code></li>
			<li><code>property::flags::DONTSHOW     </code></li>
			<li><code>property::flags::DISABLE      </code></li>
		</ul>

		<p>
			Unfortunately, in my naivety, I did not realise that the difference this provides is the ability for the editor
			and serialiser to identify if the field is meant to be displayed, and/or serialised when saving it to a file, or
			if fields are just to be displayed but not changed.
		</p>

		<p>
			This led to a lot of unnecessary complications with our component initialisation as my fellow programmers had
			the ability to reflect a variable via getter and setter functions. This meant that there was the potential of
			undefined behaviour as some functions might use uninitialised variables. While we could have just removed the
			ability for the programmer to do this, it introduced optimisation issues where additional variables might need
			to be used instead - causing the components to be unnecessarily fattened, or the inability to track if a variable
			is dirty or not.
		</p>

		<p>
			Honestly, I don't think this was an issue that got resolved properly. While we had added the initialisation
			phase to components so that the behaviour of variables that affected one another could be dealt with there, it
			did not change the fact that reflect getters and setters could not use other variables or components to
			initialise itself. I was just lucky enough that nobody else had reflected getter and setter functions that used
			variables outside of the variable it was initialising so it wasn't as problematic as it could have been.
		</p>

		<h4>Reflecting Handles</h4>

		<p>
			One of the struggles of converting from object oriented programming to move more towards data oriented (we failed
			to achieve that with our engine but an attempt was made) was to understand when the type is needed. Or, more
			precisely, when 
		</p>

		<p>
			To reflect handles, which are templated types, type based, we needed a w
		</p>

		<h4>Reflecting Enums</h4>

		<h3 id="De/Serialiser">De/Serialiser</h3>

		<p>
			One of the things that took me a really long time to understand was the "automation" of the serialiser and
			deserialiser should have used. Originally, I was under the impression that the Serialiser and Deserialiser
			should specify how each object should be de/serialised. This mistake however, led to a lot of circular
			dependencies in
		</p>

		<h3 id="Configuration Manager">Configuration Manager</h3>

		<p>
			The configuration manager acted as the manager for all "settings" files. I have come to regret the design
			decision that I went with since it was not the most refined and was born out of my ignorance to what the
			reflection system could have (should have) accomplished.
		</p>

		<p>
			The design for the configuration manager was something that we thought could go two ways:
		</p>

		<ol>
			<li>
				Type free version that uses a <code>std::variant</code> to serialise and deserialise the supported
				types so that the de/serialisation would be consistent across all config types.
			</li>
			<li>
				Inheritance version, where all configs inherit from a base config class and have a virtual
				function that can be used to serialise and deserialise itself.
			</li>
		</ol>

		<p>
			The first option gave a clean means to serialisation and deserialisation as any other user could create a
			config without worrying about how they should de/serialise them. The second provided type safety, ensuring
			the users that the data they required would exist.
		</p>

		<p>
			Naturally, properly utilising the reflection system would have given us the best of both worlds as it
			would have guarenteed both, however, since this was made before I properly understood and designed the
			reflection system, I opted to go with first option.
		</p>

		<p>
			This choice created an inconvenience, as the users will then have to manually initialise their type safe
			classes with syntax such as:
		</p>

		<code>ConfigManager::Get().GetConfig("config_name").GetField&lttype_t&gt("field_name");</code>

		<p>
			And to be safe, they would have to add many checks, such as:
		</p>

<pre class="p"><code>
    if (ConfigManager::Get().HasConfig("config_name"))
    {
        auto&& config = ConfigManager::Get().GetConfig("config_name");
        if (config.HasField&lttype_t&gt("field_name"))
        {
            auto&& config.GetField&lttype_t&gt("field_name");
        }
    }
</code></pre>

		<p>
			And a simple spelling mistake meant that they would not be able to detect the issue as easily as a compile
			error would catch it (and we all know how painful it is to have to sit through a long compile time before
			realising that there was something wrong with the code when we run it).
		</p>

		<h3 id="3D Animations">3D Animations</h3>

		<p>
			There are three parts to this task and it was one of the tasks that caused me the most infuriating griefs
			from this project. For context, I had no experience with 3D modeling or rigging and so a lot of the
			concepts flew over my head and I constantly misunderstood stuff, causing me to take a while to understand.
		</p>

		<h4>Asset Compiler</h4>

		<p>
			The first part was to have a way for us to load the resources that the artists have made. However, instead
			of personally accounting and creating multiple format loaders for each file format (not to mention how
			buggy it would be since others would know better than we do), we needed an easier, more reliable way to
			process each asset type.
		</p>

		<p>
			This is where the asset compiler came in. We made use of the library
			<a href="https://github.com/assimp/assimp">Assimp</a> to do most of the heavy lifting. It was the hub for
			the different asset types to be converted into a single assimp object which we can then use to convert into
			our own singular file format.
		</p>

		<p>
			This was difficult as we needed to properly understand how the nodes in Assimp worked. At times it was
			difficult as some of the terminology overlapped with some of the commonly used 3D modeling tools such
			as Maya. There was also an added complexity to the graphs that Assimp would build as they do not just
			handle models, but the whole scene as well. This meant that there were more information to sift through
			than just a skinned mesh and its animation. It included lights, entity paths, etc. and we needed a way
			to check if a node was truly a bone, or if it was even part of a relevant animation (multiple animations
			could exist in one scene) which is near impossible from <i>just</i> the data that Assimp provides.
		</p>

		<p>
			This forced us to impose rules on the artists when they made their models to ensure that the compiler would
			be able to identify the relevant informations from the files and build the animations proper. However, once
			that was done, it made things a lot easier for us to move forward with.
		</p>

		<h4>Bone Animation</h4>

		<p>
			This was by far one of the most difficult part of the project that I had to deal with since it involved the
			very thing I was bad at - math. It took me two weeks to implement the Bone Animations and Skinned Mesh
			Renderer because of how long it took for me to understand the hierarchy of bones and nodes, the concept of
			pre and post transformations.
		</p>

		<h4>Skinned Mesh Renderer</h4>

		<p>
		</p>

		<h3 id="Prefab System">Prefab System</h3>

		<p>
			
		</p>
	</section>

	<!------------------------------------------- Footer of page -------------------------------------------->

	<footer></footer>

	<!----------------------------------------- Footer of page End ------------------------------------------>

	<script>
		window.onload   = function() { LoadFormat("project", "eos") };
		window.onscroll = function() { StickyNavbarOnScroll()       };
		LoadFormat("project", "eos");
	</script>

</body>

</html>